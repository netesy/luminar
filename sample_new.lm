// sample.lm

// Luminar Programming Language

// Comments can be added using // for single line and /* */ for multi-line comments

/// For Ducumentation comments

  // Subtyping and Row Polymorphism:
  // Examples are already provided

  // Inline Assembly (restricted):
  // The asm expression might be restricted in future versions for safety reasons
  // asm(,...);

  // Unsafe (controlled):
  // The unsafe keyword can be used with caution for low-level features, understanding potential risks

  // Arithmetic operations:
  print(1 + 2 + (3 * 4) - (10 / 5));

(12 > 3) and (12 > 13) //false
(12 > 3) or (12 > 13) // true

(12 > 3) and (12 > 1) //true
(12 > 3) or (12 > 1) // true

(12 <= 3) and (12 >= 13) //false
(1 <= 3) or (12 >= 1) // true

  // Logical NOT:
  print(true);
  print(false);

  // Logical NOT:
  print(!true);
  print(!false);

  // Unary plus and minus:
  print(+10);
  print(-5);

  // String concatenation:
  print("Hello" + " " + "World");

  // Function with optional parameter and conditional message:
  fn greeting(name: str, date: str? = None) : str {
    const var name: str = "John"; // Use var for variable declaration
    var message: str = format!("Hello {}", name); // Use string formatting

    if date.is_some() {
      var date_str: str = date.unwrap(); // Use pattern matching for optionals
      message = format!("{}, today's date is {}", message, date_str.to_date()); // Method call on string
    }

    return message;
  }

  // Print greetings with and without date:
  print(greeting(name = "John"));
  print(greeting(name = "John", date = "12/05/2024"));

  // Control Flow Structures:

  // For loop over a range:
  for(i in 1..10) {
    print("Iteration: {}", i);
  }

  // For loop over a list:
  var my_list: list<int> = (1, 2, 3, 4, 5); // Use vector literal for list creation
  for key in my_list {
    print("{}", key);
  }

  // Iterate over dictionary:
  var my_dict: dict<str, int> = {
    "a" => 1,
    "b" => 2,
    "c" => 3,
  };// Use dictionary literal for map creation

  for((key, value) in my_dict) {
    print("{}: {}", key, value);
  }

  // While loop:
  var j: int = 0;
  while(j < 5) {
    print("While loop iteration: {}", j);
    j += 1;
  }

  // Error handling:
  fn factorial(n: int) : int? {
    if(n < 0 ) {
      return error("negative input"); // Use specific error return type
    } else if( n == 0 ){
      return 1;
    } else {
      return n * factorial(n - 1);
    }
  }

  // Function to sum elements of a list with dependent type checking (nullable support):
  fn sum(list: list<int?>) : int {
    var mut total: int = 0;
    for (item in list) {
      match (item) {
        Some(value) => total += value, // Handle Some cases
        None => continue, // Skip None values
      }
    }
    return total;
  }

  // Define a class for Person:
  class Person {
    var name: str;
    var age: int;

    Person(name: str, age: int) {
      self.name = name;
      self.age = age;
    }

    fn display() {
      print("Name: {}", self.name);
      print("Age: {}", self.age);
    }
  }

// Object of class Person:
var person1: Person = Person("Alice", 30);
person1.display();

// File I/O (experimental):
// This feature is currently under development and subject to change
// fn open(filename: str, mode: str) : File? {
//   // Implement file opening logic
// }

// fn write(file: File, data: str) {
//   // Implement file writing logic
// }

// fn close(file: File) {
//   // Implement file closing logic
// }

// Replace with alternative mechanisms for file I/O while the feature is experimental

// Modules:
// Modules provide organization and encapsulation
module Sample {

  // Strong, Static Types:
  // Examples are already provided

  // Dependent/Refinement Types (experimental):
  // The following example is currently under development
  // fn is_even(n: int) : bool? { // Use caution with experimental features
  //   if (n % 2 == 0) {
  //     return true;
  //   } else {
  //     return false;
  //   }
  }

// Concurrency and Asynchronicity (planned):
// These features are planned for future versions

// // Define a function for parallel execution
// // fn parallel_task(id:int) {
// //     print("Executing parallel task {id}");
// //     // Simulate some computation or I/O operation
//     sleep(randint(1, 3));  // Sleep for a random duration between 1 and 3 seconds
//     print("Parallel task {id} compvared");
// }
//
// // Execute multiple tasks in parallel
parallel(tasks, cores=Auto, on_error=Auto) {
    for (var i = 1; i <= 5; i++) {
        run_task(i);
    }
  }
//
//
// // Define a function for concurrent execution
// fn concurrent_task(id:int): None {
//     print("Executing concurrent task {id}");
//     // Simulate some computation or I/O operation
//     sleep(randint(1, 3));  // Sleep for a random duration between 1 and 3 seconds
//     print("Concurrent task {id} compvared");
// }
//
// // Execute multiple tasks concurrently
 concurrent(tasks, cores=Auto, on_error=Auto) {
     for (var i = 1; i <= 3; i++) {
         run_task(i);
     }
 }
//
//
// // Define a function for asynchronous execution
// async fn async_task() {
//     // Asynchronous task implementation
// }
//
// // Execute asynchronous task
// var result = await async_task();
//
// // Use result of asynchronous task
// print("Async task result: {result}");
//
// // Generics (planned):
// // This feature is planned for future versions
//
// Pattern Matching:
fn match_example(value: Any) : void { // Use Any for untyped values (caution advised)
  match value {
    int => print("The value is an integer"),
    str => print("The value is a string"),
    list<T> => print("The value is a list"), // Placeholder for generic type T
    dict<K, V> => print("The value is a dictionary"), // Placeholders for generic types K and V
    _ => print("Unknown type"),
  }
}

// Usage example:
match_example(42);
match_example("Hello");
match_example(vec!(1, 2, 3));
match_example(map!("a" => 1));
match_example(true);

} // End of Sample module

