Code snippet
// sample.lm

// Luminar Programming Language

// Comments can be added using:
//   // for single line comments
//   /* */ for multi-line comments
//   /// for documentation comments

// Luminar Key Features (refer to readme.md for details):
//   - Subtyping and Row Polymorphism
//   - Inline Assembly (Restricted) - use with caution
//   - Unsafe (Controlled) - understand risks before using

// Basic Syntax Examples

// Arithmetic operations:
print(1 + 2 + (3 * 4) - (10 / 5));  // Output: 11

// Logical Operators:
print((12 > 3) and (12 > 13));    // false (AND requires both conditions true)
print((12 > 3) or (12 > 13));    // true (OR requires at least one condition true)

// Logical NOT:
print(!true);                     // false
print(!false);                    // true

// Unary plus and minus:
print(+10);                         // 10 (unary plus is a no-op)
print(-5);                         // -5

// String concatenation:
print("Hello" + " " + "World");   // Output: Hello World

// Functions

// Function with optional parameter and conditional message:
fn greeting(name: str, date: str? = None): str {
  const var name: str = "John";      // Use `const var` for constant variables
  var message: str = format!("Hello {}", name);

  if date.is_some() {
    var date_str: str = date.unwrap();
    message = format!("{}, today's date is {}", message, date_str.to_date());
  }

  return message;
}

// Print greetings with and without date:
print(greeting(name = "John"));
print(greeting(name = "John", date = "12/05/2024"));

// Control Flow Structures

// For loop over a range:
for (i in 1..10) {
  print("Iteration: {}", i);
}

// For loop over a list:
var my_list: list<int> = (1, 2, 3, 4, 5);
for (key in my_list) {
  print("{}", key);
}

// Iterate over dictionary:
var my_dict: dict<str, int> = {
  "a": 1,
  "b": 2,
  "c": 3,
};

for ((key, value) in my_dict) {
  print("{}: {}", key, value);
}

// While loop:
var j: int = 0;
while (j < 5) {
  print("While loop iteration: {j}");
  j += 1;
}  var j: int = 0; while (j < 5) { print("While loop iteration: {j}"); j += 1;}

// Error Handling

fn factorial(n: int): int? {
  if (n < 0) {
    return error("negative input"); // Use specific error return type
  } elif (n == 0) {
    return 1;
  } else {
    return n * factorial(n - 1);
  }
}

// Function to sum elements of a list with dependent type checking (nullable support)
fn sum(list: list<int?>): int {
  var mut total: int = 0;
  for (item in list) {
    match (item) {
      Some(value) => total += value,  // Handle Some cases (values present)
      None => continue,               // Skip None values (missing values)
    }
  }
  return total;
}

// Classes

class Person {
  var name: str;
  var age: int;

  Person(name: str, age: int) {
    self.name = name;
    self.age = age;
  }

  fn display() {
    print("Name: {}", self.name);
    print("Age: {}", self.age);
  }
}

// Object of class Person:
var person1: Person = Person("Alice", 30);
person1.display();  // Output: Name: Alice, Age: 30

// File I/O (experimental):
// This feature is currently under development and subject to change
// fn open(filename: str, mode: str) : File? {
//   // Implement file opening logic
// }

// fn write(file: File, data: str) {
//   // Implement file writing logic
// }

// fn close(file: File) {
//   // Implement file closing logic
// }

// Replace with alternative mechanisms for file I/O while the feature is experimental

// Modules:
// Modules provide organization and encapsulation
module Sample {

  // Strong, Static Types:
  // Examples are already provided

  // Dependent/Refinement Types (experimental):
  // The following example is currently under development
  // fn is_even(n: int) : bool? { // Use caution with experimental features
  //   if (n % 2 == 0) {
  //     return true;
  //   } else {
  //     return false;
  //   }
  }

// Concurrency and Asynchronicity (planned):
// These features are planned for future versions

// // Define a function for parallel execution
// // fn parallel_task(id:int) {
// //     print("Executing parallel task {id}");
// //     // Simulate some computation or I/O operation
//     sleep(randint(1, 3));  // Sleep for a random duration between 1 and 3 seconds
//     print("Parallel task {id} compvared");
// }
//
// // Execute multiple tasks in parallel
parallel(tasks, cores=Auto, on_error=Auto) {
    for (var i = 1; i <= 5; i++) {
        run_task(i);
    }
  }
//
//
// // Define a function for concurrent execution
// fn concurrent_task(id:int): None {
//     print("Executing concurrent task {id}");
//     // Simulate some computation or I/O operation
//     sleep(randint(1, 3));  // Sleep for a random duration between 1 and 3 seconds
//     print("Concurrent task {id} compvared");
// }
//
// // Execute multiple tasks concurrently
 concurrent(tasks, cores=Auto, on_error=Auto) {
     for (var i = 1; i <= 3; i++) {
         run_task(i);
     }
 }
//
//
// // Define a function for asynchronous execution
// async fn async_task() {
//     // Asynchronous task implementation
// }
//
// // Execute asynchronous task
// var result = await async_task();
//
// // Use result of asynchronous task
// print("Async task result: {result}");
//
// // Generics (planned):
// // This feature is planned for future versions
//
// Pattern Matching:
fn match_example(value: Any) : void { // Use Any for untyped values (caution advised)
  match value {
    int => print("The value is an integer"),
    str => print("The value is a string"),
    list<T> => print("The value is a list"), // Placeholder for generic type T
    dict<K, V> => print("The value is a dictionary"), // Placeholders for generic types K and V
    _ => print("Unknown type"),
  }
}

// Usage example:
match_example(42);
match_example("Hello");
match_example(vec!(1, 2, 3));
match_example(map!("a" => 1));
match_example(true);

} // End of Sample module

